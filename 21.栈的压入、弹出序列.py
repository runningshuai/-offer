"""
题目描述
输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否可能为该栈的弹出顺序。假设压入栈的所有数字均不相等。
例如序列1,2,3,4,5是某栈的压入顺序，序列4,5,3,2,1是该压栈序列对应的一个弹出序列，
但4,3,5,1,2就不可能是该压栈序列的弹出序列。（注意：这两个序列的长度是相等的）
思路：
模拟入栈，出栈操作
入栈为m，给出的出栈结果为n， 引入辅助栈p，在p进行入栈和出栈操作，
若入栈顺序和出栈顺序分别和m, n相等，则m是n的出栈结果
若有不相等，则m不是n的出栈结果
1、查看n的第一个元素n[0]，p的栈顶元素p[0]需要和n[0]相等
2、若n[0] ！= p[0]， p要入栈（这时模拟的是入栈m的入栈顺序，p, m的入栈顺序都一致），直到相等；
3、若相等：n[0] == p[0]，p，n的出栈结果都一样
4、循环2，3， n[0] ！= p[0]，m没有可入栈的元素了，则返回False
5、走完全部循环，则返回True

整体思路：用辅助栈p模拟m的入栈操作和n的出栈操作，若整个流程都可以模拟则True,否则False
"""

def IsPopOrder( pushV, popV):
    # write code here
    m = pushV
    n = popV
    # 引入一个辅助栈
    p = [m.pop(0)]
    while n:
        # 若p最后一个元素和n
        while p[-1] != n[0]:
            if not m:
                return False
            p.append(m.pop(0))
        else:
            p.pop()
            n.pop(0)
    return True


print(IsPopOrder([1,2,3,4,5],[4,5,3,1,2]))
